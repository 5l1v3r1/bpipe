#!/bin/bash
#
# Bpipe Runner Script
#

# Locate Bpipe's home directory
# Need something more sophisticated to deal with symbolic links?
BPIPE_HOME=`dirname $0`/..

# Default directory for pipes - user can override by setting BPIPE_LIB themselves
: ${BPIPE_LIB:="$HOME/bpipes"}

# Last bpipe commands
if [ ! -e .bpipe/logs ];
then
    mkdir -p .bpipe/logs
fi

COMMAND="$1"
TESTMODE=""

LIB=lib
if [ -e $BPIPE_HOME/local-lib ];
then
  LIB="local-lib"
fi

CP="$BPIPE_HOME"/$LIB/bpipe.jar:"$BPIPE_HOME"/$LIB/groovy-all-1.8.2.jar:$BPIPE_HOME/$LIB/commons-cli-1.2.jar:$BPIPE_HOME/$LIB/jgraphx.jar

echo "CP=$CP"

# In case we are running in place in the bpipe project root, we pre-empt any other 
# bpipe classes with those from the build directory and the eclipse compile path
if [ -e $BPIPE_HOME/build/classes/main ];
then
  CP="$BPIPE_HOME/eclipse-build:$CP"
fi

# Token support for Cygwin: convert the class path to windows format so we can at least find the jars
if uname | grep -iq cygwin;
then
   CP=`cygpath -pw "$CP"`
fi

# If the only argument is "retry" then actually just run the previous 
if [ "$COMMAND" == "retry" ]
then
    shift 1

    if [ -e .bpipe/lastcmd ];
    then
        bash < .bpipe/lastcmd
    fi
    exit
elif [ "$COMMAND" == "history" ];
then
    shift 1
    if [ -e .bpipe/history ];
    then
        cat .bpipe/history
    else
        echo
        echo "No history found"
        echo
    fi
    exit
elif [ "$COMMAND" == "diagram" ];
then
    shift 1
    java -classpath "$CP" -Dbpipe.mode=diagram -Dbpipe.pid=$$ bpipe.Runner $* 
    exit
elif [ "$COMMAND" == "diagrameditor" ];
then
    shift 1
    java -classpath "$CP" -Dbpipe.mode=diagrameditor -Dbpipe.pid=$$ bpipe.Runner $* 
    exit
elif [ "$COMMAND" == "log" ];
then
    shift 1
    # TODO: will fail if spaces in path
    ls -tc .bpipe/logs/*.log | grep -v 'bpipe\.' | head -1 | xargs tail -f $*
    exit
elif [ "$COMMAND" == "jobs" ];
then
    if [ -e ~/.bpipedb/jobs/ ];
    then
     
        for i in ~/.bpipedb/jobs/* _ ;
        do
           base=`basename $i`
           if [ "$base" != "*" ] && [ "$i" != "_" ];
           then
               echo "$base : "`cat $i`
           fi
        done
    fi
    exit
elif [ "$COMMAND" == "run" ];
then
    shift 1
elif [ "$COMMAND" == "test" ];
then
    shift 1
    TESTMODE="-t"
    COMMAND="run"
fi

################# Default Command => Run ################

echo "$0 $COMMAND $*" > .bpipe/lastcmd
echo "$0 $COMMAND $*" >> .bpipe/history

# Run in the background with nohup so that jobs do not abort on logout
nohup java -classpath "$CP" -Dbpipe.pid=$$ bpipe.Runner $TESTMODE $* > .bpipe/logs/$$.log 2>&1 &

BPIPE_PID="$!"

# Save the job in the local folder, linked to its PID
mkdir -p .bpipe/jobs
echo "$0 $COMMAND $*" >> .bpipe/jobs/$$

# Save the job in the user's home .bpipe folder - this allows the user to query
# what jobs they have running from anywhere
# Note that it is up to the Java code to remove this when it shuts down
mkdir -p ~/.bpipedb/jobs
ln -s `pwd`/.bpipe/jobs/$$  ~/.bpipedb/jobs/$$ 

# Kill a whole tree of processes
# for some children it happens automatically, but for some it doesn't
killtree() {
    local ppid=$1
    
    # Sadly Mac OS/X does not seem to support --ppid option in default version
    # of ps
    if uname | grep -q Darwin;
    then
        pids=`ps -o pid,ppid | grep '^[0-9]' | grep ' '$ppid | cut -f 1 -d ' '`
    else
        pids=$(ps -o pid --no-headers --ppid ${ppid})
    fi
    
    if [ ! -z "$pids" ];
    then
        for child_pid in ${pids}; 
        do
            killtree ${child_pid}
        done
    fi
    kill -TERM ${ppid}
}


# Look for files marked dirty and clean them up
cleanup() {
    # Check for any unclean files in .bpipe/unclean
    if [ -f .bpipe/unclean ];
    then
        for f in `cat .bpipe/unclean`;
        do
            if [ -e "$f" ];
            then
                target=".bpipe/trash/$f"
                if [ ! -d .bpipe/trash ];
                then
                    mkdir -p .bpipe/trash
                fi
                count=1
                realtarget="$target"
                while [ -e "$realtarget" ];
                do
                  realtarget="${target}.${count}"
                  let "count = count + 1"
                done
                target="$realtarget"
                echo "Moving unclean file $f to $target"
                echo
                mv "$f" ".bpipe/trash/$f"
            fi
        done
    fi
}

# Signal handler that intercepts Ctrl+C
function end() {
    if kill -0 $BPIPE_PID  ;
    then
        echo
        read -p "Pipeline job running as process $BPIPE_PID.  Terminate? (y/n): "
        if [ "$REPLY" == "y" ];
        then
            echo
            echo "Terminating process $BPIPE_PID ..."
            killtree $BPIPE_PID

            # Don't carry on until Bpipe actually finishes
            wait $BPIPE_PID > /dev/null 2>&1
            echo 
            cleanup
        fi
    fi

    if kill -0 $TAIL_PID ;
    then
        kill $TAIL_PID
    fi
    exit
}

# Set up signal handler to trap Ctrl-C so that we can cleanly abort the job
trap end SIGINT

# Tail the output so that the user sees it
RUNPID=$$
tail -f --pid=$BPIPE_PID .bpipe/logs/$RUNPID.log 

##### Old - before I knew about tails --pid option! (todo: delete)

#TAIL_PID="$!"
# Wait for the Java Bpipe process to finish naturally (not Ctrl-C, see above for that)
#wait $BPIPE_PID

# Cygwin seems to exit too quickly, before tail even picks up the stream
# so unless we wait a tiny bit the output is truncated
#if uname | grep -iq cygwin;
#then
#  sleep 1
#fi

# Seems like The Java Bpipe process ended by itself: kill the background tail process 
# started above
#if kill -0 $TAIL_PID  ;
#then
#    kill $TAIL_PID
#fi
