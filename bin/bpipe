#!/bin/bash
#
# Bpipe Runner Script
#

# Locate Bpipe's home directory
# Need something more sophisticated to deal with symbolic links?
BPIPE_HOME=`dirname $0`/..

# Default directory for pipes - user can override by setting BPIPE_LIB themselves
: ${BPIPE_LIB:="$HOME/bpipes"}

# Last bpipe commands
if [ ! -e .bpipe ];
then
    mkdir -p .bpipe/logs
fi

COMMAND="$1"
TESTMODE=""

# If the only argument is "retry" then actually just run the previous 
if [ "$COMMAND" == "retry" ]
then
    shift 1

    if [ -e .bpipe/lastcmd ];
    then
        bash < .bpipe/lastcmd
    fi
    exit
elif [ "$COMMAND" == "history" ];
then
    shift 1
    if [ -e .bpipe/history ];
    then
        cat .bpipe/history
    else
        echo
        echo "No history found"
        echo
    fi
    exit
elif [ "$COMMAND" == "log" ];
then
	# TODO: will fail if spaces in path
	ls -tc .bpipe/logs/*.log | grep -v 'bpipe\.' | head -1 | xargs tail -f
	exit
elif [ "$COMMAND" == "jobs" ];
then
    if [ -e ~/.bpipedb/jobs/ ];
    then
	    for i in ~/.bpipedb/jobs/* _ ;
	    do
	       [ "$i" != _ ] &&  
		       echo `basename $i`" : "`cat $i`
	    done
    fi
    exit
elif [ "$COMMAND" == "run" ];
then
    shift 1
elif [ "$COMMAND" == "test" ];
then
    shift 1
    TESTMODE="-t"
    COMMAND="run"
fi

################# Default Command => Run ################

echo "$0 $COMMAND $*" > .bpipe/lastcmd
echo "$0 $COMMAND $*" >> .bpipe/history

CP="$BPIPE_HOME"/lib/bpipe.jar:"$BPIPE_HOME"/lib/groovy-all-1.8.2.jar:$BPIPE_HOME/lib/commons-cli-1.2.jar:"$BPIPE_LIB"

# Run in the background with nohup so that jobs do not abort on logout
nohup java -classpath "$CP" -Dbpipe.pid=$$ bpipe.Runner $TESTMODE $* > .bpipe/logs/$$.log 2>&1 &

BPIPE_PID="$!"

# Save the job in the local folder, linked to its PID
mkdir -p .bpipe/jobs
echo "$0 $COMMAND $*" >> .bpipe/jobs/$$

# Save the job in the user's home .bpipe folder - this allows the user to query
# what jobs they have running from anywhere
# Note that it is up to the Java code to remove this when it shuts down
mkdir -p ~/.bpipedb/jobs
ln -s `pwd`/.bpipe/jobs/$$  ~/.bpipedb/jobs/$$ 

# Kill a whole tree of processes
# for some children it happens automatically, but for some it doesn't
killtree() {
    local ppid=$1
    
    # Sadly Mac OS/X does not seem to support --ppid option in default version
    # of ps
    if uname | grep -q Darwin;
    then
        pids=`ps -o pid,ppid | grep '^[0-9]' | grep ' '$ppid | cut -f 1 -d ' '`
    else
        pids=$(ps -o pid --no-headers --ppid ${ppid})
    fi
    
    if [ ! -z "$pids" ];
    then
	    for child_pid in ${pids}; 
	    do
	        killtree ${child_pid}
	    done
    fi
    kill -TERM ${ppid}
}


# Look for files marked dirty and clean them up
cleanup() {
    # Check for any unclean files in .bpipe/unclean
    if [ -f .bpipe/unclean ];
    then
        for f in `cat .bpipe/unclean`;
        do
            if [ -e "$f" ];
            then
                target=".bpipe/trash/$f"
                echo "Moving unclean file $f to $target"
                echo
                if [ ! -d .bpipe/trash ];
                then
                    mkdir -p .bpipe/trash
                fi
                if [ -e "$target" ];
                then
                    echo "WARN: Overwriting target $target"
                    echo
                    rm "$target"
                fi
                mv "$f" ".bpipe/trash/$f"
            fi
        done
    fi
}

# Signal handler that intercepts Ctrl+C
function end() {
    if kill -0 $BPIPE_PID  ;
    then
        echo
        read -p "Pipeline job running as process $BPIPE_PID.  Terminate? (y/n): "
        if [ "$REPLY" == "y" ];
        then
            echo
            echo "Terminating process $BPIPE_PID ..."
            killtree $BPIPE_PID

            # Don't carry on until Bpipe actually finishes
            wait $BPIPE_PID > /dev/null 2>&1
            echo 
            cleanup
        fi
    fi

    if kill -0 $TAIL_PID ;
    then
        kill $TAIL_PID
    fi
    exit
}

# Set up signal handler to trap Ctrl-C so that we can cleanly abort the job
trap end SIGINT

# Tail the output so that the user sees it
tail -f .bpipe/logs/$$.log &

TAIL_PID="$!"

# Wait for the Java Bpipe process to finish naturally (not Ctrl-C, see above for that)
wait $BPIPE_PID

# Seems like The Java Bpipe process ended by itself: kill the background tail process 
# started above
if kill -0 $TAIL_PID  ;
then
    kill $TAIL_PID
fi
